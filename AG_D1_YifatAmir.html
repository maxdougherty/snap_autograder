<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Snap! Build Your Own Blocks. Beta</title>
    <link rel="shortcut icon" href="favicon.ico">
    <script src="jschannel.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script type="text/javascript">
        var pageLocation = JSON.parse(sessionStorage.getItem("pageLocation"));
        if (pageLocation) {
            parent.window.scrollTo(pageLocation[0], pageLocation[1]);
            sessionStorage.removeItem("pageLocation");
        }
    </script>
    <script type="text/javascript" src="underscore-min.js"></script>
    <!-- // <script type="text/javascript" src="SnapPLE.js"></script> -->
    <script type="text/javascript" src='gradingLog.js'></script>
    <script type="text/javascript" src='spriteEventLog.js'></script>
    <script type="text/javascript" src='scriptAnalysis.js'></script>
    <meta charset="utf-8">  <!-- This line is needed in order to pass strings into test functions that contain characters
    like "-" and what not. -->
    <!-- Moved down to the bottom to have var id. -->
    
    <!-- <script type="text/javascript" src="snap.js"></script> -->
    <script type="text/javascript" src="morphic.js"></script>
    <script type="text/javascript" src="widgets.js"></script>
    <script type="text/javascript" src="blocks.js"></script>
    <script type="text/javascript" src="threads.js"></script>
    <script type="text/javascript" src="objects.js"></script>
    <script type="text/javascript" src="gui.js"></script>
    <script type="text/javascript" src="paint.js"></script>
    <script type="text/javascript" src="lists.js"></script>
    <script type="text/javascript" src="byob.js"></script>
    <script type="text/javascript" src="xml.js"></script>
    <script type="text/javascript" src="store.js"></script>
    <script type="text/javascript" src="locale.js"></script>
    <script type="text/javascript" src="cloud.js"></script>
    <script type="text/javascript" src="sha512.js"></script>

    <link rel="stylesheet" type="text/css" href="AG_status_bar.css" />
    <link rel="stylesheet" type="text/css" href="hintstyle.css" />
    <script type="text/javascript" src="AG_hint_format.js"></script>

    <script type="text/javascript">

        var starter_path = "starter.xml";

        // The id is to act as a course identifier.
        // NOTE: FOR NOW YOU ALSO HAVE TO ADD THE ID TO THE BOTTOM OF THE PAGE.
        var courseID = "";  // e.g. "BJCx"
        // Specify a prerequisite task id, should be null if no such requirement.
        var preReqTaskID = null;
        var preReqID = courseID + preReqTaskID;
        // taskID uniquely identifies the task for saving in browser sessionStorage.
        var taskID = "AG_D1_T1";
        var id = courseID + taskID;
        var isEDX = isEDXurl();

        // Add tests to the outputLog. Function is called by runAGTest(id, outputLog)
        // var testLog;
        function AGTest(outputLog) {
/*UNIT 1*/

        /*1: Creating a Script*/

            // /*Modify given script to make the sprite follow a square path if clicked enough times.*/
            // var moveExists = function() {
            //     return spriteContainsBlock('move %n steps', 0);
            // }
            // testAssert(outputLog, moveExists,
            //     "The 'move' block is present.",
            //     "N/A",
            //     "Make sure to make your sprite move on the stage!");
            // var turnExists = function() {
            //     return spriteContainsBlock('turn %clockwise %n degrees', 0) ||
            //             spriteContainsBlock('turn %counterclockwise %n degrees', 0);
            // }
            // testAssert(outputLog, turnExists,
            //     "The 'turn' block is present.",
            //     "N/A",
            //     "Make sure your sprite turns on the stage!");
            // var turn90 = function() {
            //     return spriteContainsBlock('turn %clockwise %n degrees', 0, ["90"]) ||
            //             spriteContainsBlock('turn %counterclockwise %n degrees', 0, ["90"]);
            // }
            // testAssert(outputLog, turn90,
            //     "The turn block has an input of 90 degrees.",
            //     "N/A",
            //     "Make sure your sprite turns an appropriate amount to make a square path!");
            // var moveThenTurn = function() {
            //     return blockPrecedesInSprite("move %n steps", "turn %clockwise %n degrees", 0) ||
            //             blockPrecedesInSprite("move %n steps", "turn %counterclockwise %n degrees", 0);
            // }
            // testAssert(outputLog, moveThenTurn,
            //     "The 'turn' block follows the 'move' block in a script.",
            //     "N/A",
            //     "Make sure your sprite moves and then turns with just one click.");
            
            // Modify the previous script to make the sprite follow a triangular path if clicked enough times.
            // var moveExists = function() {
            //     return spriteContainsBlock('move %n steps', 0);
            // }
            // testAssert(outputLog, moveExists,
            //     "The 'move' block is present.",
            //     "N/A",
            //     "Make sure to make your sprite move on the stage.");
            // var turnExists = function() {
            //     return spriteContainsBlock('turn %clockwise %n degrees', 0) ||
            //             spriteContainsBlock('turn %counterclockwise %n degrees', 0);
            // }
            // testAssert(outputLog, turnExists,
            //     "The 'turn clockwise' block is present.",
            //     "N/A",
            //     "Make sure you make your sprite turns clockwise on the stage.");
            // var turn120 = function() {
            //     return spriteContainsBlock('turn %clockwise %n degrees', 0, ["120"]) ||
            //             spriteContainsBlock('turn %counterclockwise %n degrees', 0, ["120"]);
            // }
            // testAssert(outputLog, turn120,
            //     "The turn block has an input of 120 degrees.",
            //     "N/A",
            //     "Make sure your sprite turns an appropriate amount to make a triangle.");
            // var moveThenTurn = function() {
            //     return blockPrecedesInSprite("move %n steps", "turn %clockwise %n degrees", 0) ||
            //             blockPrecedesInSprite("move %n steps", "turn %counterclockwise %n degrees", 0);
            // }
            // testAssert(outputLog, moveThenTurn,
            //     "The 'turn' block follows the 'move' block in a script.",
            //     "N/A",
            //     "Make sure your sprite moves and then turns with just one click.");

        /*2: The Repeat Block*/

            // /*Input an argument value into the given script to create the given picture*/
            // var scriptExists = function() {
            //     var template = '[{"blockSp":"when %greenflag clicked","inputs":[]},{"blockSp":"pen down","inputs":[]},{"blockSp":"repeat %n %c","inputs":["A",[{"blockSp":"move %n steps","inputs":["100"]},{"blockSp":"turn %clockwise %n degrees","inputs":["80"]}]]}]';
            //     var vars = ["A"];
            //     return scriptPresentInSprite(template, 0, vars);
            // }
            // testAssert(outputLog, scriptExists,
            //     "The given script has been recreated exactly.",
            //     "N/A",
            //     "Make sure to recreate the given script!");
            // var repeat9 = function() {
            //     var script = '[{"blockSp":"when %greenflag clicked","inputs":[]},{"blockSp":"pen down","inputs":[]},{"blockSp":"repeat %n %c","inputs":["9",[{"blockSp":"move %n steps","inputs":["100"]},{"blockSp":"turn %clockwise %n degrees","inputs":["80"]}]]}]';
            //     return scriptPresentInSprite(script, 0);
            // }
            // testAssert(outputLog, repeat9,
            //     "The input to the repeat loop makes a shape with 9 sides.",
            //     "N/A",
            //     "Try checking how many sides the given shape has!");

        /*2: Nesting Repeats*/

            // //Embed one more repeat loop between move and turn.
            // var threeNestedRepeats = function() {
            //     return occurancesOfBlockInSprite("repeat %n %c", 3, 0);
            // }
            // testAssert(outputLog, threeNestedRepeats,
            //     "There are three repeat blocks in a script together.",
            //     "N/A",
            //     "Make sure to nest another repeat!");

        /*2: Adding an Input*/

            // /*Add an input to the draw square block.*/
            // var drawSquareHasInput = function() {
            //     if (findBlockInPalette("draw square %") !== null) {
            //         return true;
            //     } else {
            //         return false;
            //     }
            // }
            // testAssert(outputLog,  drawSquareHasInput,
            //     "There is a 'draw square %' block with a parameter.",
            //     "N/A",
            //     "Make sure to give your 'draw square' block a parameter.");

            // /*Add an input to the draw triangle block.*/
            // var drawTriangleHasInput = function() {
            //     if (findBlockInPalette("draw triangle %") !== null) {
            //         return true;
            //     } else {
            //         return false;
            //     
            // }
            // testAssert(outputLog,  drawTriangleHasInput,
            //     "There is a 'draw triangle %' block with a parameter.",
            //     "N/A",
            //     "Make sure to give your 'draw triangle' block a parameter.");

            // /*Add an input to the draw house block.*/
            // var drawHouseHasInput = function() {
            //     if (findBlockInPalette("draw house %") !== null) {
            //         return true;
            //     } else {
            //         return false;
            //     }
            // }
            // testAssert(outputLog,  drawHouseHasInput,
            //     "There is a 'draw house %' block with a parameter.",
            //     "N/A",
            //     "Make sure to give your 'draw house' block a parameter.");

        /*4: Commands and Reporters*/

            // /*Make the sprite move around randomly.*/
            // var penDownExists = function() {
            //     return spriteContainsBlock("pen down", 0);
            // }
            // testAssert(outputLog, penDownExists,
            //     "There is a 'pen down' block.",
            //     "N/A",
            //     "Make sure the pen is down.");
            // var loopExists = function() {
            //     return spriteContainsBlock("forever %c", 0) || spriteContainsBlock("repeat %n %c", 0);
            // }
            // testAssert(outputLog, loopExists,
            //     "There is a 'repeat' or a 'forever' block.",
            //     "N/A",
            //     "Make sure your sprite will change location continuously!");
            // var moveInLoop = function() {
            //     var moveSpec = "move %n steps";
            //     var moveInputs = [{"blockSp":"pick random %n to %n","inputs":["",""]}];
            //     var repeatSpec = "repeat %n %c";
            //     var foreverSpec = "forever %c";
            //     return CBlockContainsInSprite(moveSpec, repeatSpec, 0, moveInputs) || CBlockContainsInSprite(moveSpec, foreverSpec, 0, moveInputs);
            // }
            // testAssert(outputLog, moveInLoop,
            //     "The 'move' block is within a loop and the 'pick random' block is within the 'move' block.",
            //     "N/A",
            //     "Make sure your sprite will move continuously and randomly!");
            // var turnInLoop = function() {
            //     var turnSpec = "turn %clockwise %n degrees";
            //     var turnInputs = [{"blockSp":"pick random %n to %n","inputs":["",""]}];
            //     var repeatSpec = "repeat %n %c";
            //     var foreverSpec = "forever %c";
            //     return CBlockContainsInSprite(turnSpec, repeatSpec, 0, turnInputs) || CBlockContainsInSprite(turnSpec, foreverSpec, 0, turnInputs);
            // }
            // testAssert(outputLog, turnInLoop,
            //     "The 'turn' block is within a loop and the 'pick random' block is within the 'turn' block.",
            //     "N/A",
            //     "Make sure your sprite will turn continuously!");
            // var moveTurnSameScript = function() {
            //     return (blockPrecedesInSprite("turn %clockwise %n degrees", "move %n steps", 0) || blockPrecedesInSprite("move %n steps", "turn %clockwise %n degrees", 0));
            // }
            // testAssert(outputLog, moveTurnSameScript,
            //     "The 'move' and 'turn' blocks are in a script together.",
            //     "N/A",
            //     "Make sure your sprite will both move and turn!");

        /*4: Computer Operations*/

            // /*Create a block that reports if x is divisble by y.*/
            // var exists;
            // var divisibleExists = function() {
            //     exists = findBlockInPalette("is % divisible by % ?");
            //     if (exists !== null) {
            //         exists = true;
            //     } else {
            //         exists = false;
            //     }
            //     return exists;
            // }
            // testAssert(outputLog, divisibleExists,
            //     "There is a 'is % divisible by % ?' block.",
            //     "N/A",
            //     "Make sure you name your block exactly 'is % divisible by % ?'.");
            // multiTestBlock(outputLog, 
            //     "is % divisible by % ?", 
            //     [[1, 4], [3, 6], [6, 3], [6, 6], [4, 1], [7, 4], [-5, 5], [0, 3], [8, 5]],
            //     [false, false, true, true, true, false, true, true, false],
            //     [-1, -1, -1, -1, -1, -1, -1, -1, -1],
            //     [true, true, true, true, true, true, true, true, true],
            //     1);

        /*4: Draw a field of flowers*/

            // /*Draw a field of flowers using repeat block and randomness block and others..*/
            // var repeatExists = function() {
            //     return spriteContainsBlock("repeat %n %c", 0);
            // }
            // testAssert(outputLog, repeatExists,
            //     "There is a 'repeat' block.",
            //     "N/A",
            //     "Make sure to use a 'repeat' block!");
            // var randomExists = function() {
            //     return spriteContainsBlock("pick random %n to %n", 0);
            // }
            // testAssert(outputLog, randomExists,
            //     "There is a 'pick random' block.",
            //     "N/A",
            //     "Make sure to draw different flowers using a 'pick random' block!");
            // var drawFlowerExists = function() {
            //     return spriteContainsBlock("draw square-petal flower with % petals of size %", 0);
            // }
            // testAssert(outputLog, drawFlowerExists,
            //     "There is a 'draw square-petal flower' block.",
            //     "N/A",
            //     "Make sure to draw flowers using your 'draw square-petal flower' block!");
            // var drawInRepeat = function() {
            //     var drawFlowerSpec = "draw square-petal flower with % petals of size %";
            //     var repeatSpec = "repeat %n %c";
            //     return CBlockContainsInSprite(drawFlowerSpec, repeatSpec, 0);
            // }
            // testAssert(outputLog, drawInRepeat,
            //     "There is a 'draw square-petal flower' in a repeat loop.",
            //     "N/A",
            //     "Make sure to draw lots of flowers using a repeat loop!");

/*UNIT 2*/

        /*1: Developing a block that makes plurals*/

            /*Create a "plural %" block that makes nouns plural*/

            // //Make sure you name your block "plural %"!
            // var exists;
            // var pluralExists = function() {
            //     exists = findBlockInPalette("plural %");
            //     if (exists !== null) {
            //         exists = true;
            //     } else {
            //         exists = false;
            //     }
            //     return exists;
            // }
            // testAssert(outputLog, pluralExists,
            //     "A 'plural %' block has been found.",
            //     "N/A",
            //     "Make sure you name your block exactly 'plural %'.");
            // //possibly add an assertion checking that they have a conditional in their definition, etc. (unnecessary, given example in lab?)

            // //Make sure your block works on basic inputs!
            // multiTestBlock(outputLog, 
            //     "plural %",
            //     [["cat"], ["day"]],
            //     ["cats", "days"],
            //     [-1, -1],
            //     [true, true]);

            // //Make sure your block works when the singular word ends in 's'!
            // multiTestBlock(outputLog, 
            //     "plural %",
            //     [["boss"], ["dress"]],
            //     ["bosses", "dresses"],
            //     [-1, -1],
            //     [true, true]);

            // //Make sure your block works when the singular word ends in 'x'!
            // multiTestBlock(outputLog, 
            //     "plural %",
            //     [["fox"], ["box"]],
            //     ["foxes", "boxes"],
            //     [-1, -1],
            //     [true, true]);

        /*1: Plurals Continued*/

            /*Make a plural-h block only for words that end with "h".*/

            // //Make sure you name your block "plural-h %"!
            // var exists;
            // var pluralhExists = function() {
            //     exists = findBlockInPalette("plural-h %");
            //     if (exists !== null) {
            //         exists = true;
            //     } else {
            //         exists = false;
            //     }
            //     return exists;
            // }
            // testAssert(outputLog, pluralhExists,
            //     "A 'plural-h %' block has been found.",
            //     "N/A",
            //     "Make sure you name your block exactly 'plural-h %'.");
            // //possibly add an assertion checking that they have a conditional in their definition?

            // //Make sure your block works when the singular word ends in 'th'!
            // multiTestBlock(outputLog, 
            //     "plural-h %",
            //     [["moth"], ["sloth"]],
            //     ["moths", "sloths"],
            //     [-1, -1],
            //     [true, true]);

            // //Make sure your block works when the singular word ends in 'tch'!
            // multiTestBlock(outputLog, 
            //     "plural-h %",
            //     [["match"], ["crutch"]],
            //     ["matches", "crutches"],
            //     [-1, -1],
            //     [true, true]);

            // //Make sure your block works when the singular word ends in 'sh'!
            // multiTestBlock(outputLog, 
            //     "plural-h %",
            //     [["dish"], ["wish"]],
            //     ["dishes", "wishes"],
            //     [-1, -1],
            //     [true, true]);

            /*Use the new suffix block in the old one.*/

            // //Make sure you use your plural-h block within your plural block!
            // var hAbstracted = function() {
            //     return customBlockContains("plural %", "plural-h %");
            // }
            // testAssert(outputLog, hAbstracted,
            //     "The 'plural-h %' block has been found within the definition of 'plural %'.",
            //     "N/A",
            //     "Make sure you use your plural-h block within your plural block!");

            /*Make a plural-y block only for words that end with "y".*/

            // //Make sure you name your block "plural-y %"!
            // var exists;
            // var pluralyExists = function() {
            //     exists = findBlockInPalette("plural-y %");
            //     if (exists !== null) {
            //         exists = true;
            //     } else {
            //         exists = false;
            //     }
            //     return exists;
            // }
            // testAssert(outputLog, pluralyExists,
            //     "A 'plural-y %' block has been found.",
            //     "N/A",
            //     "Make sure you name your block exactly 'plural-y %'.");
            // //possibly add an assertion checking that they have a conditional in their definition?

            // //Make sure your block works when the second-to-last letter is a vowel!
            // multiTestBlock(outputLog, 
            //     "plural-y %",
            //     [["tray"], ["boy"]],
            //     ["trays", "boys"],
            //     [-1, -1],
            //     [true, true]);

            // //Make sure your block works when the second-to-last letter is a consonant!
            // multiTestBlock(outputLog, 
            //     "plural-y %",
            //     [["sky"], ["try"]],
            //     ["skies", "tries"],
            //     [-1, -1],
            //     [true, true]);

        /*2: Script Variables*/

            // /*Modify the script so that it also picks a size randomly from 30 to 60 using only multiples of 10*/
            // var twoPickRandoms = function() {
            //     return occurancesOfBlockInSprite("pick random %n to %n", 2, 0);
            // }
            // testAssert(outputLog, twoPickRandoms,
            //     "There are two 'pick random' blocks in the script together.",
            //     "N/A",
            //     "Make sure to set the size using the 'pick random' block!");
            // var scriptVarsExists = function() {
            //         return spriteContainsBlock("script variables %scriptVars", 0);
            // }
            // testAssert(outputLog, scriptVarsExists,
            //     "The 'script variables' block is present.",
            //     "N/A",
            //     "Make sure to use script variables in your script!");
            // //the two tests below are possibly too specific/restrictive... remove??
            // var multiplyExists = function() {
            //         return spriteContainsBlock("%n × %n", 0);
            // }
            // testAssert(outputLog, multiplyExists,
            //     "The multiplication block is present.",
            //     "N/A",
            //     "Make sure 'size' is only multiples of 10 between 30 and 60.");
            // var multiply10Exists = function() {
            //         return spriteContainsBlock("%n × %n", 0, ["10", ""]) || 
            //             spriteContainsBlock("%n × %n", 0, ["", "10"]);
            // }
            // testAssert(outputLog, multiply10Exists,
            //     "The 'size' is a multiple of 10.",
            //     "N/A",
            //     "Make sure 'size' is only multiples of 10 between 30 and 60.");

            // /*Create a factorial block.*/
            // var exists;
            // var factorialExists = function() {
            //     exists = findBlockInPalette("% !");
            //     if (exists !== null) {
            //         exists = true;
            //     } else {
            //         exists = false;
            //     }
            //     return exists;
            // }
            // testAssert(outputLog, factorialExists,
            //     "There is a '% !' factorial block.",
            //     "N/A",
            //     "Make sure you name your block exactly '% !'.");
            // var multiplyExists = function() {
            //         return spriteContainsBlock("%n × %n", 0);
            // }
            // testAssert(outputLog, multiplyExists,
            //     "The multiplication block is present.",
            //     "N/A",
            //     "Make sure to look at the definition of factorial.");
            // var repeatExists = function() {
            //     return spriteContainsBlock("repeat %n %c", 0) || 
            //         spriteContainsBlock("repeat until %b %c", 0) ||
            //         spriteContainsBlock("for %upvar = %n to %n %cs", 0);
            // }
            // testAssert(outputLog, repeatExists,
            //     "There is a 'repeat' block.",
            //     "N/A",
            //     "Make sure to use a 'repeat' block!");
            // multiTestBlock(outputLog, 
            //     "% !", 
            //     [[0], [1], [2], [3], [4], [5]],
            //     [1, 1, 2, 6, 24, 120],
            //     [-1, -1, -1, -1, -1, -1],
            //     [true, true, true, true, true, true],
            //     1);

            // /*Create a triangular number block.*/
            // var exists;
            // var triangularNumberExists = function() {
            //     exists = findBlockInPalette("triangular number %");
            //     if (exists !== null) {
            //         exists = true;
            //     } else {
            //         exists = false;
            //     }
            //     return exists;
            // }
            // testAssert(outputLog, triangularNumberExists,
            //     "There is a 'triangular number %' block.",
            //     "N/A",
            //     "Make sure you name your block exactly 'triangular number %'.");
            // var addExists = function() {
            //         return spriteContainsBlock("%n + %n", 0);
            // }
            // testAssert(outputLog, addExists,
            //     "The addition block is present.",
            //     "N/A",
            //     "Make sure to look at the definition of triangular number!");
            // multiTestBlock(outputLog, 
            //     "triangular number %", 
            //     [[0], [1], [2], [3], [4], [5]],
            //     [0, 1, 3, 6, 10, 15],
            //     [-1, -1, -1, -1, -1, -1],
            //     [true, true, true, true, true, true],
            //     1);

            // /*Create a raise n to the power of b block.*/
            // var exists;
            // var raiseExists = function() {
            //     exists = findBlockInPalette("raise % to the power of %");
            //     if (exists !== null) {
            //         exists = true;
            //     } else {
            //         exists = false;
            //     }
            //     return exists;
            // }
            // testAssert(outputLog, raiseExists,
            //     "There is a 'raise % to the power of %' block.",
            //     "N/A",
            //     "Make sure you name your block exactly 'raise % to the power of %'.");
            // var multiplyExists = function() {
            //         return spriteContainsBlock("%n × %n", 0);
            // }
            // testAssert(outputLog, multiplyExists,
            //     "The multiplication block is present.",
            //     "N/A",
            //     "Make sure to look at the definition of the power function!");
            // multiTestBlock(outputLog, 
            //     "raise % to the power of %", 
            //     [[2, 3], [3, 4], [2, 5], [2, 1], [8, 0]],
            //     [8, 81, 32, 2, 1],
            //     [-1, -1, -1, -1, -1],
            //     [true, true, true, true, true],
            //     1);

        /*2: Building a useful collection of predicates.*/

            /*Create "even? %" predicate block.*/
            
            // //Make sure you name your block "even? %"!
            // var exists;
            // var evenExists = function() {
            //     exists = findBlockInPalette("even? %");
            //     if (exists !== null) {
            //         exists = true;
            //     } else {
            //         exists = false;
            //     }
            //     return exists;
            // }
            // testAssert(outputLog, evenExists,
            //     "A 'even? %' block has been found.",
            //     "N/A",
            //     "Make sure you name your block exactly 'even? %'.");

            // //Make sure your block is a predicate: it returns true/false values.
            // var predicate = function() {
            //     var customBody = getCustomBody("even? %");
            //     return ((customBlockContains("even? %", "report %", ["true"]) && 
            //         customBlockContains("even? %", "report %", ["false"])) || 
            //         (blockPrecedes("report %", "% = %", customBody))); 
            //         //assuming they are reporting the equals block --> boolean value
            // }
            // testAssert(outputLog, predicate,
            //     "The 'even? %' block returns a boolean value.",
            //     "N/A",
            //     "Make sure your block returns the true/false booleans!");

            // //Try using the "mod" block in your solution!
            // var usesMod = function() {
            //     return customBlockContains("even? %", "% mod %");
            // }
            // testAssert(outputLog, usesMod,
            //     "The 'even? %' block uses the 'mod' block in its defintion.",
            //     "N/A",
            //     "Try using the 'mod' block in your solution!");

            // //Make sure your block works on basic inputs!
            // multiTestBlock(outputLog, 
            //     "even? %",
            //     [[2], [3], [645361]],
            //     [true, false, false],
            //     [-1, -1, -1],
            //     [true, true, true]);

            // //Make sure your block works when the input is zero!
            // multiTestBlock(outputLog, 
            //     "even? %",
            //     [[0]],
            //     [true],
            //     [-1],
            //     [true]);

            /*Create "% >= %" predicate block.*/
            
            // //Make sure you name your block "% >= %"!
            // var exists;
            // var gtoetExists = function() {
            //     exists = findBlockInPalette("% >= %");
            //     if (exists !== null) {
            //         exists = true;
            //     } else {
            //         exists = false;
            //     }
            //     return exists;
            // }
            // testAssert(outputLog, gtoetExists,
            //     "A '% >= %' block has been found.",
            //     "N/A",
            //     "Make sure you name your block exactly '% >= %'.");

            // //Make sure your block is a predicate: it returns true/false values.
            // var predicate = function() {
            //     var customBody = getCustomBody("% >= %");
            //     return ((customBlockContains("% >= %", "report %", ["true"]) && 
            //         customBlockContains("% >= %", "report %", ["false"])) || 
            //         (blockPrecedes("report %", "% or %", customBody)) || 
            //         (blockPrecedes("report %", "not %", customBody))); 
            //         //assuming they are reporting the OR or NOT block --> boolean value
            // }
            // testAssert(outputLog, predicate,
            //     "The '% >= %' block returns a boolean value.",
            //     "N/A",
            //     "Make sure your block returns the true/false booleans!");

            // //Try using the "or" block in your solution!
            // var usesOrNot = function() {
            //     return customBlockContains("% >= %", "% or %") ||
            //             customBlockContains("% >= %", "not %");
            // }
            // testAssert(outputLog, usesOrNot,
            //     "The '% >= %' block uses either the 'or' block or the 'not' block in its defintion.",
            //     "N/A",
            //     "Try using the 'or' block or the 'not' block in your solution!");

            // //Make sure your block works on basic inputs!
            // multiTestBlock(outputLog, 
            //     "% >= %",
            //     [[2, 3], [3, 2], [645361, -645361], [3, 3]],
            //     [false, true, true, true],
            //     [-1, -1, -1, -1],
            //     [true, true, true, true]);

            /*Create "integer? %" predicate block.*/
            
            // //Make sure you name your block "integer? %"!
            // var exists;
            // var integerExists = function() {
            //     exists = findBlockInPalette("integer? %");
            //     if (exists !== null) {
            //         exists = true;
            //     } else {
            //         exists = false;
            //     }
            //     return exists;
            // }
            // testAssert(outputLog, integerExists,
            //     "A 'integer? %' block has been found.",
            //     "N/A",
            //     "Make sure you name your block exactly 'integer? %'.");

            // //Make sure your block is a predicate: it returns true/false values.
            // var predicate = function() {
            //     var customBody = getCustomBody("integer? %");
            //     return ((customBlockContains("integer? %", "report %", ["true"]) && 
            //         customBlockContains("integer? %", "report %", ["false"])) || 
            //         (blockPrecedes("report %", "% = %", customBody))); 
            //         //assuming they are reporting the equals block --> boolean value
            // }
            // testAssert(outputLog, predicate,
            //     "The 'integer? %' block returns a boolean value.",
            //     "N/A",
            //     "Make sure your block returns the true/false booleans!");

            // //Try using the "round" block or the "mod" block in your solution!
            // var usesRoundMod = function() {
            //     return (customBlockContains("integer? %", "round %") || 
            //             customBlockContains("integer? %", "% mod %"));
            // }
            // testAssert(outputLog, usesRoundMod,
            //     "The 'integer? %' block uses either the 'round' block or the 'mod' block in its defintion.",
            //     "N/A",
            //     "Try using the 'round' block or the 'mod' block in your solution!");

            // //Make sure your block works on basic inputs!
            // multiTestBlock(outputLog,
            //     "integer? %",
            //     [[2], [2.55], [-6453], [0]],
            //     [true, false, true, true],
            //     [-1, -1, -1, -1],
            //     [true, true, true, true]);

            /*Create "% between? % and %" predicate block.*/
            
            // //Make sure you name your block "% between? % and %"!
            // var exists;
            // var betweenExists = function() {
            //     exists = findBlockInPalette("% between? % and %");
            //     if (exists !== null) {
            //         exists = true;
            //     } else {
            //         exists = false;
            //     }
            //     return exists;
            // }
            // testAssert(outputLog, betweenExists,
            //     "A '% between? % and %' block has been found.",
            //     "N/A",
            //     "Make sure you name your block exactly '% between? % and %'.");

            // //Make sure your block is a predicate: it returns true/false values.
            // var predicate = function() {
            //     var customBody = getCustomBody("% between? % and %");
            //     return ((customBlockContains("% between? % and %", "report %", ["true"]) && 
            //         customBlockContains("% between? % and %", "report %", ["false"])) || 
            //         (blockPrecedes("report %", "% and %", customBody))); 
            //         //assuming they are reporting the AND block --> boolean value
            // }
            // testAssert(outputLog, predicate,
            //     "The '% between? % and %' block returns a boolean value.",
            //     "N/A",
            //     "Make sure your block returns the true/false booleans!");

            // //Try using the "and" block in your solution!
            // var usesAnd = function() {
            //     return customBlockContains("% between? % and %", "% and %");
            // }
            // testAssert(outputLog, usesAnd,
            //     "The '% between? % and %' block uses the 'and' block in its defintion.",
            //     "N/A",
            //     "Try using the 'and' block in your solution!");

            // //Make sure your block works on basic inputs!
            // multiTestBlock(outputLog,
            //     "% between? % and %",
            //     [[2, 3, 4], [2.55, 2, 3], [-5, 0, -6], [0, 7, 2]],
            //     [false, true, true, false],
            //     [-1, -1, -1, -1],
            //     [true, true, true, true]);

            /*Create "weekend? %" predicate block.*/
            
            // //Make sure you name your block "weekend? %"!
            // var exists;
            // var weekendExists = function() {
            //     exists = findBlockInPalette("weekend? %");
            //     if (exists !== null) {
            //         exists = true;
            //     } else {
            //         exists = false;
            //     }
            //     return exists;
            // }
            // testAssert(outputLog, weekendExists,
            //     "A 'weekend? %' block has been found.",
            //     "N/A",
            //     "Make sure you name your block exactly 'weekend? %'.");

            // //Make sure your block is a predicate: it returns true/false values.
            // var predicate = function() {
            //     var customBody = getCustomBody("weekend? %");
            //     return ((customBlockContains("weekend? %", "report %", ["true"]) && 
            //         customBlockContains("weekend? %", "report %", ["false"])) || 
            //         (blockPrecedes("report %", "% or %", customBody))); 
            //         //assuming they are reporting the OR block --> boolean value
            // }
            // testAssert(outputLog, predicate,
            //     "The 'weekend? %' block returns a boolean value.",
            //     "N/A",
            //     "Make sure your block returns the true/false booleans!");

            // //Try using the "or" block in your solution!
            // var usesOr = function() {
            //     return customBlockContains("weekend? %", "% or %");
            // }
            // testAssert(outputLog, usesOr,
            //     "The 'weekend? %' block uses the 'or' block in its defintion.",
            //     "N/A",
            //     "Try using the 'or' block in your solution!");

            // //Make sure your block works on basic inputs!
            // multiTestBlock(outputLog,
            //     "weekend? %",
            //     [["Saturday"], ["Sunday"], ["Monday"], ["Tuesday"]],
            //     [true, true, false, false],
            //     [-1, -1, -1, -1],
            //     [true, true, true, true]);

            /*Create "weekday? %" predicate block.*/
            
            // //Make sure you name your block "weekday? %"!
            // var exists;
            // var weekdayExists = function() {
            //     exists = findBlockInPalette("weekday? %");
            //     if (exists !== null) {
            //         exists = true;
            //     } else {
            //         exists = false;
            //     }
            //     return exists;
            // }
            // testAssert(outputLog, weekdayExists,
            //     "A 'weekday? %' block has been found.",
            //     "N/A",
            //     "Make sure you name your block exactly 'weekday? %'.");

            // //Make sure your block is a predicate: it returns true/false values.
            // var predicate = function() {
            //     var customBody = getCustomBody("weekday? %");
            //     return ((customBlockContains("weekday? %", "report %", ["true"]) && 
            //         customBlockContains("weekday? %", "report %", ["false"])) || 
            //         (blockPrecedes("report %", "not %", customBody))); 
            //         //assuming they are reporting the NOT block --> boolean value
            // }
            // testAssert(outputLog, predicate,
            //     "The 'weekday? %' block returns a boolean value.",
            //     "N/A",
            //     "Make sure your block returns the true/false booleans!");

            // //Try using the "weekend? %" block in your solution!
            // var usesWeekend = function() {
            //     return customBlockContains("weekday? %", "weekend? %");
            // }
            // testAssert(outputLog, usesWeekend,
            //     "The 'weekday? %' block uses the 'weekend? %' block in its defintion.",
            //     "N/A",
            //     "Try using the 'weekend? %' block in your solution!");

            // //Make sure your block works on basic inputs!
            // multiTestBlock(outputLog,
            //     "weekday? %",
            //     [["Saturday"], ["Sunday"], ["Monday"], ["Tuesday"]],
            //     [false, false, true, true],
            //     [-1, -1, -1, -1],
            //     [true, true, true, true]);

        /*3: Composition of Functions*/

            /*Create "Are any equal? % and % and %" predicate block.*/
            
            // //Make sure you name your block "Are any equal? % and % and %"!
            // var exists;
            // var anyEqualExists = function() {
            //     exists = findBlockInPalette("Are any equal? % and % and %");
            //     if (exists !== null) {
            //         exists = true;
            //     } else {
            //         exists = false;
            //     }
            //     return exists;
            // }
            // testAssert(outputLog, anyEqualExists,
            //     "An 'Are any equal? % and % and %' block has been found.",
            //     "N/A",
            //     "Make sure you name your block exactly 'Are any equal? % and % and %'.");

            // //Make sure your block is a predicate: it returns true/false values.
            // var predicate = function() {
            //     var customBody = getCustomBody("Are any equal? % and % and %");
            //     return ((customBlockContains("Are any equal? % and % and %", "report %", ["true"]) && 
            //         customBlockContains("Are any equal? % and % and %", "report %", ["false"])) || 
            //         (blockPrecedes("report %", "% or %", customBody))); 
            //         //assuming they are reporting the OR block --> boolean value
            // }
            // testAssert(outputLog, predicate,
            //     "The 'Are any equal? % and % and %' block returns a boolean value.",
            //     "N/A",
            //     "Make sure your block returns the true/false booleans!");

            // //Try using the "% or %" block in your solution!
            // var usesOr2 = function() {
            //     return customBlockContains("Are any equal? % and % and %", "% or %");
            // }
            // testAssert(outputLog, usesOr2,
            //     "The 'Are any equal? % and % and %' block uses the '% or %' block in its defintion.",
            //     "N/A",
            //     "Try using the '% or %' block in your solution!");

            // //Make sure your block works on basic inputs!
            // multiTestBlock(outputLog,
            //     "Are any equal? % and % and %",
            //     [[2, 3, 4], [-2, 0, 2], [6, 3, 6], [1, 2, 2]],
            //     [false, false, true, true],
            //     [-1, -1, -1, -1],
            //     [true, true, true, true]);

            return outputLog;
        }

        /* Removes the previously saved AG_state. Runs the tests in
         * AGTest().
         * Called by 'click' event on autograder_button.
         */
        function runAGTest(snapWorld, taskID, outputLog) {
            // Create a new gradingLog if none is specified.
            var numAttempts = setNumAttempts(taskID);
            outputLog = outputLog || new gradingLog(snapWorld, taskID, numAttempts);
            // Populate, run, and evaluate the tests specified in AGTest()
            // These tests specified by the Course Designer. 

            //outputLog.numAttempts += 1;

            var test_log = AGTest(outputLog);
            if(!test_log.runSnapTests()) {
                outputLog.scoreLog();
            }
        }

        /* After loading the XML, check if the current XML is a known
         * state, restore the gradingLog if it is.
         * @return {gradingLog}
         * TODO: Trigger AGStart when a Snap file is loaded.
         */
        function AGStart(snapWorld, taskID) {
            //Grab HTML divs
            var menu_button = document.getElementById("onclick-menu");
            var grade_button = document.getElementById("autograding_button");
            //Get the current Snap XML string
            var ide = snapWorld.children[0];
            var curr_xml = ide.serializer.serialize(ide.stage);
            //Retrieve previously graded Snap XML strings (if in sessionStorage).
            var c_prev_xml = sessionStorage.getItem(taskID + "_c_test_state");
            var prev_xml = sessionStorage.getItem(taskID + "_test_state");

            var outputLog;
            //If the current XML matches the stored correct XML
            if (isSameSnapXML(c_prev_xml, curr_xml)) {
                //Restore the AG status bar to a graded state
                var outputLog = JSON.parse(sessionStorage.getItem(taskID + "_c_test_log"));
                outputLog.snapWorld = snapWorld;
                AG_bar_graded(outputLog);
                return outputLog;
            }
            //If the current XML matches the last stored gradingLog
            if (isSameSnapXML(prev_xml, curr_xml)) {
                //Restore the AG status bar to a graded state
                var outputLog = JSON.parse(sessionStorage.getItem(taskID + "_test_log"));
                outputLog.snapWorld = snapWorld;
                AG_bar_semigraded(outputLog);
                return outputLog; 
            } else {
                //Restore the AG status bar to a graded state
                //If no previous state is recognized, return new {gradingLog}.
                var numAttempts = setNumAttempts(taskID);
                outputLog = new gradingLog(snapWorld, taskID, numAttempts); 
                AG_bar_ungraded(outputLog);
                return outputLog;
            }   
        }
        /* Checks to see if the Snap! XML has changed and updates the
         * AG status bar. If Snap! is restored to its former state
         * the grading log and status bar are also restored.
         * @return {gradingLog} outputLog
         * Note:
         *  - Should only be called from a "mouseup" event.
         */
        function AGUpdate(snapWorld, taskID) {

            

            //TODO: Are there any optional parameters that may be useful?
            //Grabs HTML divs
            var menu_button = document.getElementById("onclick-menu");
            var grade_button = document.getElementById("autograding_button");
            //Get the current Snap XML string
            var ide = snapWorld.children[0];
            var curr_xml = ide.serializer.serialize(ide.stage);
            //Retrieve previously graded Snap XML strings (if in sessionStorage).
            var c_prev_xml = sessionStorage.getItem(taskID + "_c_test_state");
            var prev_xml = sessionStorage.getItem(taskID + "_test_state");

            //var last_xml = sessionStorage.getItem(taskID + "_last_submitted_state");
            //Retrieve previous grade logs (if in sessionStorage). As {String}s
            var c_prev_log = sessionStorage.getItem(taskID + "_c_test_log");
            var prev_log = sessionStorage.getItem(taskID + "_test_log");
            if (!prev_xml || !curr_xml) {
                // console.log(prev_xml);
                // console.log(curr_xml);
            }
            //menu bar grays out options that are not available 
            //(ex. current state is same as best attempt) and restores the button state
            grayOutButtons(snapWorld, taskID);
            var outputLog;
            //If current XML is different from prev_xml
            if (c_prev_xml && isSameSnapXML(c_prev_xml, curr_xml)) {               
                //Restore the AG status bar to a graded state
                
                // TODO: Write a good comment
                // TODO: Give gradeLog ability to recover log data and xml string
                console.log('AGUpdate: Thinks this is the "correct" XML.');
                sessionStorage.setItem(taskID + "_test_log", c_prev_log);
                sessionStorage.setItem(taskID + "_test_state", curr_xml);
                document.getElementById("different-feedback").innerHTML = "";

                //Retrieve the correct test log from sessionStorage
                outputLog = JSON.parse(c_prev_log);
                outputLog.snapWorld = snapWorld;
                AG_bar_graded(outputLog);

                if (isEDX) {
                    parent.document.getElementById('overlay-button').style.display = "none";
                }

            } else if (prev_xml && isSameSnapXML(prev_xml, curr_xml, true)) {
                //Restore the AG status bar to a graded state
                console.log('AGUpdate: Thinks this is just the "last" XML.');
                //Retrieve the previous test log from sessionStorage
                document.getElementById("different-feedback").innerHTML = "";

                outputLog = JSON.parse(prev_log);
                outputLog.snapWorld = snapWorld;
                AG_bar_semigraded(outputLog);
                if (isEDX) {
                    parent.document.getElementById('overlay-button').style.display = "none";
                }

            } else {
                //Restore the AG status bar to a graded state
                var numAttempts = setNumAttempts(taskID);
                outputLog = new gradingLog(snapWorld, taskID, numAttempts);
                //outputLog = JSON.parse(prev_log);
                //outputLog.snapWorld = snapWorld;
                AG_bar_ungraded(outputLog);
                document.getElementById("different-feedback").innerHTML = "This feedback does not match what is in the scripting area."
                if (isEDX) {
                    parent.document.getElementById('overlay-button').style.display = "block";
                }

            }
            //populateFeedback(outputLog);
            return outputLog;

        }

        /* Updates the AG_status_bar with respect to the outputLog. 
         *  - Formats CSS for 'autograding_flag' and 'autograding_button'
         * If the outputLog is correct, save the Snap XML string into 
         * sessionStorage.
         *  - key = outputLog.taskID + "_c_test_state"
         * Note:
         *  - Should only be called from outputLog.evaluateLog()
         */
        function AGFinish(outputLog) {
            // Verify correctness
            if (outputLog.allCorrect) {
                // Save the correct XML string into sessionStorage
                AG_bar_graded(outputLog);
                outputLog.saveSnapXML(outputLog.taskID + "_c_test_state");
            } else {
                // Update AG_status_bar to 'graded, but incorrect state
                AG_bar_semigraded(outputLog);
            }
            //Save the current XML. Log is saved in gradingLog.scoreLog(...)
            outputLog.saveSnapXML(outputLog.taskID + "_test_state");
            //outputLog.numAttempts += 1;
            populateFeedback(outputLog);
            grayOutButtons(outputLog.snapWorld, outputLog.taskID);
            console.log('Autograder test Results:');
            console.log(outputLog);
            //populateFeedback(outputLog);
            if (isEDX) {
                parent.document.getElementsByClassName('check-label')[0].click();
            } 
            //parent.document.getElementsByClassName('check-label')[0].click();
        }
        /*
         * Reset state removes all saved logs and XML files, and opens a new
         * Snap! file. 
         */
        function resetState(snapWorld, taskID) {

            var numAttempts = JSON.parse(sessionStorage.getItem(taskID + "_test_log")).numAttempts;

            sessionStorage.removeItem(taskID + "_test_log");
            sessionStorage.removeItem(taskID + "_test_state");
            sessionStorage.removeItem(taskID + "_c_test_log");
            sessionStorage.removeItem(taskID + "_c_test_state");

            var ide = snapWorld.children[0];

            if (starter_path) {
                $.get(starter_path, function(data) {
                ide.openProjectString(data)}, 
                "text");
            } else {
                ide.newProject();
            }
            var new_log = AGStart(snapWorld, taskID);
            new_log.numAttempts = numAttempts;
            //sessionStorage.setItem(taskID + "_test_log", new_log);
            sessionStorage.setItem(taskID + "_test_state", ide.serializer.serialize(ide.stage));
            new_log.saveLog();
            //sessionStorage.setItem(taskID + "_test_log", new_log);
            grayOutButtons(snapWorld, taskID);
        }

        function revertToBestState(snapWorld, taskID) {
    
            var ide = snapWorld.children[0];

            var numAttempts = JSON.parse(sessionStorage.getItem(taskID + "_test_log")).numAttempts;

            var c_prev_xml = sessionStorage.getItem(taskID + "_c_test_state");
            var c_prev_log = sessionStorage.getItem(taskID + "_c_test_log");
            sessionStorage.setItem(taskID + "_test_state", c_prev_xml);
            sessionStorage.setItem(taskID + "_test_log", c_prev_log);

            var prev_log = JSON.parse(sessionStorage.getItem(taskID + "_test_log"));
            prev_log.snapWorld = snapWorld;
            AG_bar_graded(prev_log);
            populateFeedback(prev_log);
            prev_log.numAttempts = numAttempts;
            ide.openProjectString(c_prev_xml);
            grayOutButtons(snapWorld, taskID);
        }

        function revertToLastState(snapWorld, taskID) {

            var ide = snapWorld.children[0];
            var prev_xml = sessionStorage.getItem(taskID + "_test_state");
            var prev_log = JSON.parse(sessionStorage.getItem(taskID + "_test_log"));
            prev_log.snapWorld = snapWorld;
            if (prev_log['allCorrect']) {
                AG_bar_graded(prev_log);
            } else {
                AG_bar_semigraded(prev_log);
            }
            populateFeedback(prev_log);
            ide.openProjectString(prev_xml);
            grayOutButtons(snapWorld, taskID);
        }

        /*function revertToLastSubmit(snapWorld, taskID) {
            var numAttempts = JSON.parse(sessionStorage.getItem(taskID + "_test_log")).numAttempts;

            var last_xml = sessionStorage.getItem(taskID + "_last_submitted_state");
            var last_log = sessionStorage.getItem(taskID + "_last_submitted_log");
            var ide = snapWorld.children[0];

            sessionStorage.setItem(taskID + "_test_state", last_xml);
            sessionStorage.setItem(taskID + "_test_log", last_log);
            var prev_log = JSON.parse(sessionStorage.getItem(taskID + "_test_log"));
            if (prev_log['allCorrect']) {
                AG_bar_graded(prev_log);
            } else {
                AG_bar_semigraded(prev_log);
            }
            populateFeedback(prev_log);
            prev_log.numAttempts = numAttempts;
            ide.openProjectString(last_xml);
            grayOutButtons(snapWorld, taskID);

        }*/

        /*
         * Makes AG status bar reflect the ungraded state of the outputLog.
         */
        function AG_bar_ungraded(outputLog) {
            var button_text = "GRADE";
            var button_elem = $('#autograding_button span');
            var regex = new RegExp(button_text,"g");
            if (button_elem.html().match(regex) !== null) {
                return;
            }
            button_elem.fadeOut('fast', function() {
                button_elem.html(button_text);
                button_elem.slideDown('fast');
                $('#autograding_button').css('background', 'orange');
            });          
            $('#autograding_button .hover_darken').show();
            $('#onclick-menu').css('color', 'white');
            if (sessionStorage.getItem(outputLog.taskID + "_test_log")) {
                $('#feedback-button').html("View Previous Feedback");
            } else {
                $('#feedback-button').html("No Feedback Available");
            }
            document.getElementById("different-feedback").innerHTML = "This feedback does not match what is in the scripting area."
        }

        /*
         * Makes AG status bar reflect the graded state of the outputLog. This
         * only occurs when all tests on the outputLog have passed.
         */
        function AG_bar_graded(outputLog) {
            var button_text = "TESTS PASS";
            var button_elem = $('#autograding_button span');
            var regex = new RegExp(button_text,"g");
            if (button_elem.html().match(regex) !== null) {
                return;
            }
            button_elem.fadeOut('fast', function() {
                button_elem.html(button_text);
                button_elem.slideDown('fast');
                $('#autograding_button').css('background', '#29A629');
            });
            $('#autograding_button .hover_darken').hide();
            $('#onclick-menu').css('color', 'white');
            $('#feedback-button').html("Review Feedback");
        }
        /*
         * Makes AG status bar reflect the semi graded state of the outputLog. 
         * This is called when any test on the outputLog fails.
         */
        function AG_bar_semigraded(outputLog) {
            var button_text = "&#x2770&#x2770 FEEDBACK";
            var button_elem = $('#autograding_button span');
            var regex = new RegExp("FEEDBACK","g");
            var num_errors = outputLog.testCount - outputLog.numCorrect;
            var plural = "";
            if (num_errors > 1) { plural = "s"};
            $('#feedback-button').html("View Feedback ("+ 
                num_errors +" Error" + plural + ")");
            if (button_elem.html().match(regex) !== null) {
                return;
            }
            button_elem.fadeOut('fast', function() {
                button_elem.html(button_text);
                button_elem.slideDown('fast');
                $('#autograding_button').css('background', 'red');
            });
            $('#autograding_button .hover_darken').show();
            $('#onclick-menu').css('color', 'orange');
        }

        /* Checks if two Snap! XML strings have approximately the same state.
         * The positions of scripts are ignored, as well as the order in which
         * they were most recently manipulated. 
         * @param {String} prev_xml
         * @param {String} curr_xml
         * @return {Boolean} Equivalence of prev_xml and curr_xml, false if
         * either are strings are undefined.
         * Currently only works for one sprite with scripts
         * TODO: Extend to all script groups [DONE]
         * TODO: Improve XML scrubbing (Consider the following)
         *  - If correct solution (scripts) is subset of other [DONE]
         *  - Optional tags for variables, sprite position  
         *  - Option to restore the highest scoring {gradingLog}
         *  
         * Note: Apparently works with multiple sprites, but produces a malformed
         * Snap XML string. Each sprite gets all scripts in sorted order. Needs
         * further testing.
        */
        function isSameSnapXML(prev_xml, curr_xml, no_subset) {
            //replace script coordinates with generic 'x="0" y="0"'
            // console.log('isSameSnapXML');
            if ((prev_xml === null) || (curr_xml === null)) { return false; }
            //Remove script coordinates
            // prev_xml = prev_xml.replace(/script x="[\d]*" y="[\d]*"/g, 'script x="0" y="0"');
            // curr_xml = curr_xml.replace(/script x="[\d]*" y="[\d]*"/g, 'script x="0" y="0"');
            prev_xml = prev_xml.replace(/script x="(.*?)" y="(.*?)"/g, 'script x="0" y="0"');
            curr_xml = curr_xml.replace(/script x="(.*?)" y="(.*?)"/g, 'script x="0" y="0"');
            //Remove data hashes hashes (to allow coherence b/w reloads).
            prev_xml = prev_xml.replace(/data:image(.*?)(?=<)/g, '');
            curr_xml = curr_xml.replace(/data:image(.*?)(?=<)/g, '');
            //If XML is identical other than images and script positions, short-circuit
            if (prev_xml === curr_xml) { return true; }
            //split between brackets
            prev_xml_scripts = prev_xml.match(/(<script x)(.*?)(<\/script>)/g);
            curr_xml_scripts = curr_xml.match(/(<script x)(.*?)(<\/script>)/g);
            //split between custom blocks
            prev_xml_blocks = prev_xml.match(/(<block-definition s)(.*?)(\/block-definition>)/g);
            curr_xml_blocks = curr_xml.match(/(<block-definition s)(.*?)(\/block-definition>)/g);
            //sort script tags and convert back to strings
            //lol. weird syntax. doesn't sort if curr_xml_scripts === null.
            prev_xml_scripts && prev_xml_scripts.sort().join("");
            curr_xml_scripts && curr_xml_scripts.sort().join("");
            //If the custom block definitions have changed
            prev_xml_blocks && prev_xml_blocks.sort().join("");
            curr_xml_blocks && curr_xml_blocks.sort().join("");
            if(JSON.stringify(prev_xml_blocks) !== JSON.stringify(curr_xml_blocks)) {
                return false;
            }
            //If the previous scripts are a subset of current scripts
            if (!no_subset && isArrSubset(curr_xml_scripts, prev_xml_scripts)) {
                //Then the solution is still present and in-tact
                return true;
            }
            //replace unsorted scripts with sorted scripts
            //TODO: Replace them properly
            prev_xml = prev_xml.replace(/(<script x)(.*)(<\/script>)/g,prev_xml_scripts);
            curr_xml = curr_xml.replace(/(<script x)(.*)(<\/script>)/g,curr_xml_scripts);
            return prev_xml === curr_xml;
        }

        /*
         * Helper Function for isSameSnapXML(...). Used to check if a previous
         * solution is a sub-set of the current Snap! scripts.
         * @param {Array:Strings} big
         * @param {Array:String} small
         * @return {Boolean} If 'small' is a sub-set of 'big'
         */
        function isArrSubset(big, small) {
            if (!big || !small) {
                return false;
            }
            nbig = big.slice();
            var index;
            for (var elem of small) {
                index = nbig.indexOf(elem);
                if (nbig.indexOf(elem) >= 0) {
                    nbig.slice(index, 1);
                } else {
                    return false;
                }
            }
            return true;
        }

        function escapeRegExp(string) {
            return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
        }

        function replaceall(string, find, replace) {
            return (string.replace(new RegExp(escapeRegExp(find), 'g'), replace));
        }

        /*
         * Re-format the contents of a the hint string to add HTML tags and
         * appropriate CSS. Return the re-formatted string.
         */
        function formatFeedback(hint) {
            var tags = 
            [['collapsedivstart', '<input class="toggle-box" id="expander" type="checkbox" ><label for="expander">Details</label><div id="table-wrapper">'], 
            ['collapsedivend', '</div>'], 
            ['linebreak', '<br /></br />'], 
            ['tablestart', '<table class="results">'], 
            ['tableend', '</table>'], 
            ['rowstart', '<tr>'], 
            ['rowend', '</tr>'], 
            ['headstart', '<th class="titles" style="text-align: center;">'], 
            ['headend', '</th>'], 
            ['datastart', '<td class="data" style="text-align: center;">'], 
            ['evenstart', '<td class="evens" style="text-align: center;">'],
            ['dataend', '</td>'], 
            ['correctstart', '<td class="correctans" style="text-align: center;">'],
            ['wrongstart', '<td class="incorrectans" style="text-align: center;">'],
            ['teststart', '<td class="tests" style="text-align: center;">'],
            ['spanend', '</span>'], 
            ['spanstart', '<span class="message">']];

            var taglength = tags.length;
            var message = String(hint.innerHTML);

            for (var i = 0; i < taglength; i++) {
                message = replaceall(message, tags[i][0], tags[i][1]);
            }
            return message;
        }


        function toggleMenu() {
            var menu_items = document.getElementsByClassName("bubble")[0];
            if (menu_items.id === "dropdown-closed") {
                menu_items.id = "dropdown-open";
            } else {
                menu_items.id = "dropdown-closed";
            }
        }

        function openPopup(){
            var overlay = document.getElementById('overlay');
            overlay.classList.remove("is-hidden");
        }

        function closePopup(){
            var overlay = document.getElementById('overlay');
            overlay.classList.add("is-hidden");
        }

        function openResults(){
            var overlay = document.getElementById('ag-output');
            overlay.classList.remove("is-hidden");
        }

        function closeResults(){
            var overlay = document.getElementById('ag-output');
            overlay.classList.add("is-hidden");
        }

        function populateFeedback(outputLog) {
            var taskID = outputLog.taskID;
            //var last_log = sessionStorage.getItem(taskID + "_last_submitted_log");
            var prev_log = sessionStorage.getItem(taskID + "_test_log");
            var edx_caution = document.getElementById("edx-submit-different");
            var caution = document.getElementById("different-feedback");

            console.log(outputLog);
            var glog = outputLog;
            var log = AG_log(glog);
            var feedback = log["feedback"];
            var title = log["comment"];

            console.log(feedback);

            // Checks if the grading button has been clicked
            if (title === "Please run the Snap Autograder before clicking the 'Submit' button.") {
                document.getElementById("table-data").style.display = "none";
                document.getElementById("reporter-table-data").style.display = "none";
            } else {
                document.getElementById("table-data").style.display = "table";
                document.getElementById("reporter-table-data").style.display = "table";
            }

            // Wipes the feedback clean, including if it has been populated before. 
            caution.innerHTML = "";
            edx_caution.innerHTML = "";
            document.getElementById("comment").innerHTML = "";
            var tableTitles = document.getElementsByClassName("titles");
            var tableResults = document.getElementById("table-data");
            var repTableResults = document.getElementById("reporter-table-data");
            while (tableResults.children.length > 1) {
                tableResults.removeChild(tableResults.children[1]);
            }
            while (repTableResults.children.length > 1) {
                repTableResults.removeChild(repTableResults.children[1]);
            }

            // Warnings for when student's feedback differ from what's on the scripting area/what's been submitted to edX
            document.getElementById("comment").innerHTML = title + "(" + String(Math.round(feedback["totalPoints"] * feedback["pScore"])) + "/" + String(feedback["totalPoints"]) + ")";
            /*if (!last_log) {
                edx_caution.innerHTML = "[WARNING: You have not submitted your results to edX yet.]"
            }
            else if (last_log !== prev_log) {
                edx_caution.innerHTML = "[WARNING: These results differ from your last edX submission.]"
            }*/

            var nonRepTest = 1;
            var repTest = 1;
            for (i=1; i<=feedback["testCount"]; i++) {
                var test = String(i);
                console.log(test);
                var newRow = document.createElement("tr");

                // If test is not a reporter test, only add columns for Test # and Feedback
                if (feedback[test]["testClass"] !== "r") {
                    if (document.getElementsByClassName("non-reporter").length === 0) {
                        addBasicHeadings();
                    }
                    addTableCell(String(nonRepTest), "tests", newRow);
                    if (nonRepTest % 2 === 0) {
                        addTableCell(feedback[test]["pointValue"], ["data", "evens"], newRow);
                    } else {
                        addTableCell(feedback[test]["pointValue"], "data", newRow);
                    }
                    nonRepTest += 1;
                }

                // If test is a reporter test, add all columns, including input, output, and expected. Makes the background of every other row light gray.
                if (feedback[test]["testClass"] === "r") {
                    if (document.getElementsByClassName("reporter").length === 0) {
                        addReporterHeadings();
                    }
                    addTableCell(String(repTest), "tests", newRow);
                    var keys = ["pointValue", "blockSpec", "input", "output", "expOut"];
                    for (key=0; key<keys.length; key++) {
                        if (keys[key] === "blockSpec") {
                            var blockSpec = feedback[test][keys[key]];
                            // var blockSpecSliced = blockSpec.slice(2, blockSpec.length - 2);
                            // console.log(blockSpecSliced);
                            if (repTest % 2 === 0) {
                                addTableCell(blockSpec, ["data", "evens"], newRow);
                            } else {
                                addTableCell(blockSpec, "data", newRow);
                            }
                        } else {
                            if (repTest % 2 === 0) {
                                addTableCell(feedback[test][keys[key]], ["data", "evens"], newRow);
                            } else {
                                addTableCell(feedback[test][keys[key]], "data", newRow);
                            }
                        }
                    }
                    repTest += 1;
                }

                // If test is correct, make the feedback appropriately colored. 
                if (feedback[test]["correct"] === true) {
                    addTableCell(feedback[test]["feedback"], "correctans", newRow);
                    //addRegradeButton("Regrade", ["data", "hidden"], newRow);
                } else {
                    addTableCell(feedback[test]["feedback"], "incorrectans", newRow);
                    //addRegradeButton("Regrade", ["data", "regrade", test], newRow);
                }

                if (feedback[test]["testClass"] === "r") {
                    document.getElementById("reporter-table-data").appendChild(newRow);
                } else {
                    document.getElementById("table-data").appendChild(newRow);
                }  
            }
            console.log(outputLog);
            //outputLog.saveLog();

            // makes recently created regrade buttons clickable 
            /*var regrade_buttons = document.getElementsByClassName("regrade");
            for(var i=0; i<regrade_buttons.length; i++) {
                regrade_buttons[i].onclick = function() {
                    var testId = this.classList[2];
                    regradeOnClick(outputLog, testId);
                }
            }*/
        }

        function addBasicHeadings() {
            basicCols = ["Test", "Points", "Feedback"];
            for (i=0; i<basicCols.length; i++) {
                var header = document.createElement("th");
                var text = document.createTextNode(basicCols[i]);
                //var lastCol = document.getElementById("reporter-last-column");
                var titles = document.getElementById("table-titles");
                header.classList.add("titles", "non-reporter");
                header.appendChild(text);
                titles.appendChild(header);
            }
        }

        function addReporterHeadings() {
            var columns = ["Test", "Points", "Block", "Input", "Output", "Expected", "Feedback"];
            for (i=0; i<columns.length; i++) {
                var header = document.createElement("th");
                var text = document.createTextNode(columns[i]);
                var repTitles = document.getElementById("reporter-table-titles");
                header.classList.add("titles", "reporter");
                header.appendChild(text);
                repTitles.appendChild(header);
            }
        }

        function addTableCell(text, elemClass, row) {
            var data = document.createElement("td");
            var text = document.createTextNode(text);
            data.appendChild(text);
            if (Array.isArray(elemClass)) {
                DOMTokenList.prototype.add.apply(data.classList, elemClass);
            } else {
                data.classList.add(elemClass);
            }
            row.appendChild(data);
        }

        function addRegradeButton(text, elemClass, row) {
            var data = document.createElement("td");
            var button = document.createElement("p");
            var text = document.createTextNode(text);
            button.classList.add("regrade-button");
            button.appendChild(text);
            data.appendChild(button);
            if (Array.isArray(elemClass)) {
                DOMTokenList.prototype.add.apply(data.classList, elemClass);
            } else {
                data.classList.add(elemClass);
            }
            row.appendChild(data);
        }

        function grayOutButtons(snapWorld, taskID) {
            var ide = snapWorld.children[0];
            var curr_xml = ide.serializer.serialize(ide.stage);
            //Retrieve previously graded Snap XML strings (if in sessionStorage).
            var c_prev_xml = sessionStorage.getItem(taskID + "_c_test_state");
            var prev_xml = sessionStorage.getItem(taskID + "_test_state");

            /*var last_xml = sessionStorage.getItem(taskID + "_last_submitted_state");

            var last_submit = document.getElementById("last-submit");
            if (last_xml === null || isSameSnapXML(last_xml, curr_xml)) {
                last_submit.style.color = "#373737";
                last_submit.style.pointerEvents = "none";
                last_submit.parentNode.id = "disabled-button";
            } else {
                last_submit.parentNode.id = "enabled-button";
                last_submit.style.color = "white";
                last_submit.style.pointerEvents = "auto";
            }*/

            var revert_button = document.getElementById("revert-button");
            if (c_prev_xml === null || isSameSnapXML(c_prev_xml, curr_xml)) {
                revert_button.style.color = "#373737";
                revert_button.style.pointerEvents = "none";
                revert_button.parentNode.id = "disabled-button";
            } else {
                revert_button.parentNode.id = "enabled-button";
                revert_button.style.color = "white";
                revert_button.style.pointerEvents = "auto";
            }

            var undo_button = document.getElementById("undo-button");
            if (prev_xml === null || isSameSnapXML(prev_xml, curr_xml)) {
                undo_button.style.color = "#373737";
                undo_button.style.pointerEvents = "none";
                undo_button.parentNode.id = "disabled-button";
            } else {
                undo_button.parentNode.id = "enabled-button";
                undo_button.style.color = "white";
                undo_button.style.pointerEvents = "auto";
            }
        }

        function regradeOnClick(outputLog, testId) {
            var test = outputLog[testId];
            test.graded = false;
            test.correct = false;
            outputLog.numAttempts += 1;
            if (test.testClass === "r") {
                outputLog.startSnapTest(parseInt(testId, 10));

            // for assertion tests, change feedback accordingly to whether assertion is true or false
            } else if (test.testClass === "a") {
                if (test.assertion()) {
                    test.feedback = test.pos_fb;
                    test.correct = true;
                } else {
                    test.feedback = test.neg_fb;
                    test.correct = false;
                }
                test.graded = true;
            }

            //What about other types of tests?

            outputLog.scoreLog();
            console.log(outputLog);
        }

        function setNumAttempts(taskID) {
            var prev_log = sessionStorage.getItem(taskID + "_test_log");
            if (prev_log !== null && JSON.parse(prev_log).numAttempts !== undefined) {
                return JSON.parse(prev_log).numAttempts;
            } else {
                return 0;
            }
        }

        function isEDXurl() {
            var url = window.location.href;
            if (url.indexOf("edx") !== -1) {
                return true;
            } else {
                return false;
            }
        }

        function makeOverlayButton() {
            var overlay_button = parent.document.createElement('button');
            var overlay_button_text = parent.document.createTextNode('Grade');
            overlay_button.appendChild(overlay_button_text);
            overlay_button.id = 'overlay-button';
            var button =  parent.document.getElementsByName('problem_id')[0];
            button.parentNode.insertBefore(overlay_button, button.nextSibling);
        }

        function makeFullScreenButton() {
            var autograding_bar = document.getElementById('autograding_bar');
            var full_screen_button = document.createElement('button');
            var full_screen_button_text = document.createTextNode("Full-Screen");
            full_screen_button.appendChild(full_screen_button_text);
            full_screen_button.id = "full-screen";
            full_screen_button.className = "off";
            autograding_bar.parentNode.insertBefore(full_screen_button, autograding_bar.nextSibling);
        }

        function toggleSnapWindow(button) {
            var iframe = parent.document.getElementsByTagName('iframe')[0];
            if (button.className === "off") {
                fullScreenSnap(button);
            } else {
                iframe.style.position = 'initial';
                iframe.style.top = 'initial';
                iframe.style.right = 'initial';
                //iframe.style.width = 'initial';
                iframe.style.height = '500px';
                iframe.style.zIndex = 'initial';
                button.className = "off";
                button.innerHTML = "Full-Screen";
                sessionStorage.removeItem("full-screen-on");
                /*button.style.position = 'absolute';
                button.style.right = '31px';
                button.style.bottom = '225px';*/
            }
        }

        function fullScreenSnap(button) {
            var iframe = parent.document.getElementsByTagName('iframe')[0];
            iframe.style.position = 'fixed';
            iframe.style.top = '0';
            iframe.style.right = '0';
            iframe.style.width = '100%';
            iframe.style.height = '100vh';
            iframe.style.zIndex = '16777270';
            button.className = "on";
            button.innerHTML = "Windowed";
            sessionStorage.setItem("full-screen-on", JSON.stringify(true));
        }

        /*var pageLocation = JSON.parse(sessionStorage.getItem("pageLocation"));

        if (pageLocation) {
            parent.window.scrollTo(pageLocation[0], pageLocation[1]);
            sessionStorage.removeItem("pageLocation");
        }*/

        /*$( parent.document ).ready(function() {
            var pageLocation = JSON.parse(sessionStorage.getItem("pageLocation"));

            if (pageLocation) {
                parent.window.scrollTo(pageLocation[0], pageLocation[1]);
                sessionStorage.removeItem("pageLocation");
            }
        });*/

        var world;
        window.onload = function () {

            /*var pageLocation = sessionStorage.getItem("pageLocation");

            if (pageLocation) {
                parent.window.scrollTo(pageLocation[0], pageLocation[1]);
            }*/

            //check if attempt num for problem exists in session storage:

            //AUTOGRADER ADDITION - FEEDBACK FORMATTING
            // Checks if problem has been checked and modifies the autograded output if it has been checked

            if (parent.document.getElementsByClassName("message").length !== 0) {
                var hint = parent.document.getElementsByClassName("message")[0];
                hint.innerHTML = formatFeedback(hint);
                hint.style.display = "inline";
            }


            //INITIALIZE UP SNAP
            world = new WorldMorph(document.getElementById('world'));
            new IDE_Morph().openIn(world);
            


            var ide = world.children[0];
            //console.log(starterXML);
            //ide.openProjectString(starterXML);

            //Reduce Stage Size on initialization
            ide.toggleStageSize(true);

            //AUTOGRADER ADDITION
            //Check if Pre-requisite task has completed
            var req_check = parent.document.getElementById("pre_req");
            if (preReqTaskID !== null) {
                var preReqLog = JSON.parse(sessionStorage.getItem(preReqID + "_test_log"));
                if ((preReqLog === null || !preReqLog.allCorrect) && req_check) {
                    req_check.innerHTML = "[WARNING: The previous task must be completed before continuing.]"
                }
            }

            //If page has already been loaded, restore previously tested XML
            //TODO: Separate this into its own function.
            var prev_xml = sessionStorage.getItem(id + "_test_state");
            if (prev_xml !== null) {
                ide.openProjectString(prev_xml);
            } else if (preReqTaskID !== null) {
                if (preReqLog !== null && preReqLog.allCorrect) {
                    ide.openProjectString(sessionStorage.getItem(preReqID));
                }
            }

            /*var starter_xml = sessionStorage.getItem("starter_file");
            if (starter_xml) {
                ide.openProjectString(starter_xml);
                //sessionStorage.removeItem("starter_file");
            }*/


            if (isEDX) {
                parent.document.getElementsByClassName('check-label')[0].onclick = function () {
                    sessionStorage.setItem("pageLocation", JSON.stringify([parent.window.scrollX, parent.window.scrollY]));
                }
            }
            

            //AUTOGRADER ADDITION - 
            //Forced to use setTimeout() to let the world load before... Maybe not.
            
            //Create a gradingLog and initialize the AG status bar (AGSB).
            // var testLog = AGStart(world, id);

            //Initialize AGSB button.
            var grade_button = document.getElementById("autograding_button");
            grade_button.style.cursor = "pointer";
            //Call the test suite when this element is clicked.
            var update_listener = function() {
                var outputLog = AGUpdate(world, id);
                //populateFeedback(outputLog);
                //runAGTest(world, id);
            };
            var button_listener = function(event) {
                event.stopPropagation();
                console.log('PROPAGATION SHOULD STOP');
                var numAttempts = setNumAttempts(id);
                outputLog = new gradingLog(world, id, numAttempts);
                outputLog.numAttempts += 1;
                runAGTest(world, id, outputLog);
                //sessionStorage.setItem("pageLocation", [parent.window.scrollY, parent.window.scrollX]);
                // var outputLog = AGStart(world, id);
            }
            grade_button.addEventListener('click', button_listener);
            var world_canvas = document.getElementById('world');
            world_canvas.addEventListener("mouseup", update_listener);
            

            // grade_button.onclick = function(event) {
            //     // event.stopPropagation();
            //     runAGTest(world, id);
            //     var outputLog = AGStart(world, id);
            //     //console.log(outputLog);
            //     //populateFeedback(outputLog);
            // }



            var reset_button = document.getElementById("reset-button");
            var revert_button = document.getElementById("revert-button");
            var undo_button = document.getElementById("undo-button");
            //var last_submit = document.getElementById("last-submit");
            //var menu_button = document.getElementById("hamburger-menu");
            var menu_button = document.getElementsByClassName("onclick-menu")[0];
            //var help_menu = document.getElementById("circle");
            var help_overlay = document.getElementById('overlay');
            var feedback_button = document.getElementById("feedback-button");
            var results_overlay = document.getElementById("ag-output");
            var snapWorld = document.getElementById("world");
            var regrade_buttons = document.getElementsByClassName("regrade");
            
            //var outside_menu = document.getElementById("outside-menu");

            reset_button.onclick = function() { resetState(world, id); toggleMenu(id); };
            revert_button.onclick = function() { revertToBestState(world, id); toggleMenu(id); };
            //last_submit.onclick = function() { revertToLastSubmit(world, id); toggleMenu(id); };
            undo_button.onclick = function() { revertToLastState(world, id); toggleMenu(id); };
            menu_button.onclick = function() { toggleMenu(id); };
            //var overlay_button = parent.document.getElementById('overlay-button');
            //overlay_button.onclick = function() { grade_button.click(); }

            $(".bubble").click(function(event){ event.stopPropagation(); });

            feedback_button.onclick = function() {openResults(); };

            help_overlay.onclick = function(e) {
                if (!(document.getElementById('help-popup').contains(e.target))) {
                    closePopup();
                }
            }

            results_overlay.onclick = function(e) {
                if (!(document.getElementById('ag-results').contains(e.target)) && e.target.className.indexOf("regrade") === -1) {
                    closeResults();
                }
            }

            snapWorld.onclick = function(e) {
                if (document.getElementById('dropdown-open') !== null && !(document.getElementById('onclick-menu').contains(e.target))) {
                    toggleMenu();
                }
            }


            /*outside_menu.onclick = function(e) {
                if (document.getElementById('dropdown-open') !== null && !(document.getElementById('onclick-menu').contains(e.target))) {
                    toggleMenu();
                }
            }*/

            /* Check if the snap xml has changed "significantly".
             * Exclude script position and edit history.
             */


            document.addEventListener("click", function() {
                grayOutButtons(world, id);
            });

            if (isEDX) {
                makeOverlayButton();
                var overlay_button = parent.document.getElementById('overlay-button');
                //overlay_button.style.display = "block";
                overlay_button.onclick = function() { 
                    overlay_button.style.display = "none";
                    grade_button.click(); 
                }

                makeFullScreenButton();
                var full_screen = document.getElementById('full-screen');
                full_screen.onclick = function() {
                    toggleSnapWindow(full_screen);   
                }

                var full_screen_on = JSON.parse(sessionStorage.getItem("full-screen-on"));
                if (full_screen_on) {
                    fullScreenSnap(full_screen);
                }
            }

            IDE_Morph.prototype.originalOpenProject = IDE_Morph.prototype.openProjectString;
            IDE_Morph.prototype.openProjectString = function (name) {
                this.originalOpenProject(name);
                setTimeout(function() {
                    AGUpdate(world, id);
                }, 500);
            }

            IDE_Morph.prototype.originalCloudOpenProject = IDE_Morph.prototype.openCloudDataString;
            IDE_Morph.prototype.openCloudDataString = function (name) {
                this.originalCloudOpenProject(name);
                setTimeout(function() {
                    AGUpdate(world, id);
                }, 500);
            }

            IDE_Morph.prototype.originalToggleStageSize = IDE_Morph.prototype.toggleStageSize;
            IDE_Morph.prototype.toggleStageSize = function (isSmall) {
                this.originalToggleStageSize(isSmall);
                setTimeout(function() {
                    moveAutogradingBar()
                }, 100);
            }

            function moveAutogradingBar() {
                var autograding_bar = document.getElementById('autograding_bar');
                var ide = world.children[0];
                if (ide.stageRatio === 1) {
                    autograding_bar.style.right = '9em';
                } else {
                    autograding_bar.style.right = '16em';
                }
            }

            /*setTimeout(function() {
                var pageLocation = JSON.parse(sessionStorage.getItem("pageLocation"));

                if (pageLocation) {
                    parent.window.scrollTo(parseInt(pageLocation[0]), parseInt(pageLocation[1]));
                    sessionStorage.removeItem("pageLocation");
                }
            }, 3000);*/


            //TODO: Fix this timeout.
            setTimeout(function() {

                console.log(world);
                var outputLog = AGStart(world,id);
                //for some reason, the for loop in populateFeedback doesn't increment correctly the first time it is run, so populateFeedback has to be called twice at the very beginning...
                populateFeedback(outputLog); 
                populateFeedback(outputLog); 
                


                var starter_xml = sessionStorage.getItem("starter_file");
                if (starter_xml) {
                    ide.openProjectString(starter_xml);
                    sessionStorage.removeItem("starter_file");
                }

                //runAGTest(world, id);
                //runAGTest(world, id);

                /*if (isEDX) {
                    var full_screen = parent.document.getElementById('full-screen');
                    full_screen.onclick = function() {
                        toggleSnapWindow(full_screen);   
                    }
                }*/

                //for some reason, the for loop in populateFeedback doesn't increment correctly the first time it is run, so populateFeedback has to be called twice at the very beginning...
                //populateFeedback(outputLog);
                //populateFeedback(outputLog);
                grayOutButtons(world, id);

                /*$(".regrade").click(function() {
                    var testId = this.classList[2];
                    var test = outputLog[testId];
                    test.graded = false;
                    test.correct = false;
                    outputLog.scoreLog;
                    console.log(outputLog);
                    var mylog = outputLog;
                    //this.classList[2]); 
                });*/

                
                /*for (i=0; i<regrade_buttons.length; i++) {
                    regrade_buttons[i].setAttribute('onclick', 'alert("hello")');
                }*/
                //populateFeedback(outputLog);
                //var outputLog = AGStart(world,id);
                //populateFeedback(outputLog);

                //for some reason, the for loop in populateFeedback doesn't increment correctly the first time it is run, so runAGTest has to be called twice at the very beginning...
                //runAGTest(world,id);
                //runAGTest(world,id);
                //AGUpdate(world, id);

                
            },500);

            /*var overlay_button = document.createElement('button');
            var overlay_button_text = document.createTextNode('Grade');
            overlay_button.appendChild(overlay_button_text);
            overlay_button.id = 'overlay-button';
            alert(parent.document.getElementsByName('action').length);
            parent.document.getElementsByName('action')[0].appendChild(overlay_button);*/

            //runAGTest(world,id);
            //AGUpdate(world, id);

            setInterval(loop, 1);
            
        };

        function loop() {
            world.doOneCycle();
        }

    </script>
    <script type="text/javascript" src="AG_EDX.js"></script>
</head>
<body style="margin: 0;">
    <canvas id="world" tabindex="1" style="position: absolute;" ></canvas>



<!-- Snap Autograding Button -->
<div id="autograding_bar">
    <div tabindex="0" class="onclick-menu" id='onclick-menu' style="display:inline-block">
        <span title="Menu">&#9776;</span>
        <div class='hover_darken'></div>
      <nav id="navigation" class="site-navigation" role="navigation">
          <ul id="dropdown-closed" class="bubble">
            <li class="menu-item-sub-menu" id="enabled-button"><a id="feedback-button">View Feedback</a></li>
            <li class="menu-divider-sub-menu" id='menu-divider'></li>
            <li class="menu-item-sub-menu" id="enabled-button"><a id="revert-button">Revert To Best Attempt</a></li>
            <!--<li class="menu-item-sub-menu" id="enabled-button"><a id="last-submit">Revert To Last edX Submission</a></li>-->
            <li class="menu-item-sub-menu" id="enabled-button"><a id="undo-button">Revert To Last Attempt</a></li>
            <li class="menu-item-sub-menu" id="enabled-button"><a id="reset-button">Reset</a></li>
            <li class="menu-divider-sub-menu" id='menu-divider'></li>
            <li class="menu-item-sub-menu" id='enabled-button' onclick="openPopup();"><a id="help-button">Help</a></li>
          </ul>
    </nav>
    </div>
    <div id="autograding_button" style="display:inline-block;">
        <span></span>
        <div class='hover_darken'></div>
    </div>
</div>
<!-- Snap Autograding Menu -->
<!-- Autograding Menu Help Button -->
<div class="overlay is-hidden" id="overlay">
    <div class="popup-content" id="help-popup">
        <span class="button-close" onclick="closePopup();">X</span>
            <img id="example-image" src="edX_snap_example.png">
            <p id="full-screen-arrow">&#8600;</p>
            <p id="full-screen-help">This full-screen button will pop out the Snap! window.</p>
            <p id="menu-item-arrow">&#8599;</p>
            <p id="menu-item-help">The first menu item will display the results from running the autograder.</br></br>The next three menu items will revert your current Snap! state to one of your previous attempts, depending on whether you wish to revert to your last correct attempt, to the attempt that edX has recorded, or just to your last graded attempt.</br></br>The 'Reset' button will revert to a blank Snap! project, or to a provided starter file if one is given for this problem.</p>
            <p id="ag-button-arrow">&#8593;</p>
            <p id="ag-button-help">Clicking this button will grade your current attempt and send the results to edX.</p>
            <p>
                Please remember to click the 'Submit' button below the Snap! window to obtain credit for this problem!
            </p>
    </div>
</div>

<div style="display:inline-block" class="view-results" id="circle" onclick="openResults();">Results
</div>
<div class="overlay is-hidden" id="ag-output">
    <div class="popup-content" id="ag-results">
        <span class="button-close" onclick="closeResults();" id="popup">X</span>
        <p id = "different-feedback"></p>
        <p id = "edx-submit-different"></p>
        <p id="comment"></p>
        <table class="results">
            <tbody id="table-data">
                <tr id="table-titles"> 
                    <!--<th class="titles"> Test </th> 
                    <th class="titles" id="last-column"> Feedback </th>-->
                </tr>
            </tbody>
        </table>
        </br>
        <table class="results">
            <tbody id="reporter-table-data">
                <tr id="reporter-table-titles"> 
                    <!--<th class="titles"> Test </th> 
                    <th class="titles" id="last-column"> Feedback </th>-->
                </tr>
            </tbody>
        </table>
    </div>
</div>
    </div>
    <script type="text/javascript" src="AG_status_bar.js" />
</body>
</html>
